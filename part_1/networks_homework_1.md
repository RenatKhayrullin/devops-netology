Task 2: \
На сколько я понимаю, в большинстве стран для частоты 2,4GHz Wi-Fi устройства стандартизированы на использование 1-13 каналов.
Тут таблица для устройств Juniper \
https://www.juniper.net/documentation/en_US/release-independent/junos/topics/reference/specifications/access-point-ax411-country-channel-support.html.

Task 3: \
```38F9D3555579``` -- Apple, Ink.

Task 4: \
```EHTERNET = ETHERNET_HEADER(14 byte) + IP_HEADER(20 byte) + TCP_HEADER(32 byte) + APP_DATA + ETHERNET_TAILER(4 byte)```\
```EHTERNET_MTU = IP_HEADER(20 byte) + TCP_HEADER(32 byte) + APP_DATA (n bytes)``` \
```EHTERNET_PAYLOAD = EHTERNET_MTU - IP_HEADER - TCP_HEADER = 9001 - 20 - 32 = 8949```

Task 5: \
При нормальном поведении TCP, флаги SYN и FIN не должны одновременно быть равны 1 на одном и том же пакете. \
Но есть другие протоколы, работающие поверх TCP, в которых данное поведение допустимо, например RST.

Task 6: \
```ss -ula sport = :53``` -- показывает состояние слушающего 53го UDP порта.\
В UDP протоколе нет концепции сессий, по этому UDP может быть только в двух, на сколько я понял, состояниях: \
```ESTAB``` -- с UDP портом установлено соединение. \
```UNCONN``` -- UDP порт в состояния "прослушивания".
```TIME-WAIT``` -- состояние TCP порта.

Task 7:\
Ответ в Task 9.

Task 8: \
TCP порт – 16 битное число --> максимальное значение помещаемое в 16 бит - 65536.\
Соответственно, если ip адрес клиента и сервера фиксированы и единичны;\
предполагается, что экземпляр сервера -- единичный (нет балансировки соединеий на кластер серверов);\
и при этом к серверу подключается только данный клиент;\
то с клиента можно установить ```65536 = 2^16``` параллельных соединений к серверу.

Т.к. TCP содержит:\
source ip (2^32), source port (2^16), destination ip (2^32),  destination port (2^16)

Теоретические число соединений которое может обслужить сервер на одном порту: 
```<число различных ip> * <число портов> = 2^48```,
Теоретические число всевозможных соединений к серверу:
```<число различных ip> * <число портов> * <число портов сервера> = 2^64```

Выше приведены лишь комбинаторные оценки числа соединений, допустимых протоколом TCP, \
реальная пропускной способностью серверов гораздо ниже, и ограничена аппаратными характеристиками.

Task 9:\
Большое число соединений TCP на хосте может находиться в состоянии TIME-WAIT.\
Главная опасность которою несет разрастание очереди TIME_WAIT на сервере — это исчерпание ресурсов.\

«Активная» сторона -- сторона инициировавшая закрытие соединения. \
«Пассивная» сторона -- вторая сторона.\
Причем не важно, кто из них был инициатором установки соединения.

«Пассивная» сторона: 
1. Получает 1-A-FIN пакет и должна ответить на него соответствующим 1-П-ACK-пакетом, но имеет право продолжить отправку данных.\
С момента получения 1-A-FIN пакета соединение у пассивной стороны находится в состоянии CLOSE_WAIT.\
2. По готовности «пассивная» сторона отправляет ответный 1-П-FIN-пакет, после чего «пассивная» сторона дожидается 1-A-ACK пакета на него.\
и по получении — соединение для пассивной стороны закрывается.

«Активная сторона»
1. После отправки 1-A-FIN-пакета «активная сторона» переходит в состояние FIN_WAIT_1.

Далее возможны три ситуации: \
2. Получение 1-П-ACK пакета на отправленный 1-A-FIN-пакет. Этот статус обозначен FIN_WAIT_2, стороне могут быть доставлены данные, после чего ожидается получение 1-П-FIN-пакета от «пассивной» стороны, на который активная сторона отвечает 1-A-ACK и переводит соединение в состояние TIME_WAIT. \
3. Если пассивная сторона готова к закрытию сессии, то ответный 1-П-FIN может быть получен с одновременным 1-П-ACK на 1-А-FIN пакет. В этом случае активная сторона отвечает на него 1-A-ACK и переводит соединение в TIME_WAIT, минуя FIN_WAIT_2. \
4. Возможна ситуация когда стороны одновременно инициировали закрытие. В этом случае обе стороны являются «активными», с обеих сторон соединение переходит в состояние TIME_WAIT. \

Т.к. отправитель не знает, доставлен ли 1-A-ACK, то переходит в TIME_WAIT состояние.

Пусть, есть клиент, который активно подключается/отключается к удаленному серверу. \
И пусть оба IP и удаленный порт остаются неизменными, тогда на каждое новое соединение в клиенте выделяется новый локальный порт. \
Если клиент был активной стороной завершения TCP-сессии, то это соединение будет заблокировано какое-то время в состоянии TIME_WAIT. \
Если соединения устанавливаются быстрее, чем порты выходят из ожидания, то при очередной попытке соединения клиент получит ошибку EADDRNOTAVAIL (errno=99).

Даже если приложения обращаются к разным службам, и ошибка не происходит, очередь TIME_WAIT будет расти, забирая системные ресурсы.

Task 10:
В TCP пакеты имеют порядок и переотправку утерянных пакетов, то в случае с фрагментацией будет просто снижена производительность.\
В UDP нет механизма упорядочивания и переотправки утерянных пакетов, то фрагментации стоит избегать, ничего не гарантирует доставки пакета в целостности.

Фрагментированный UDP трафик может проходить через брандмауэры на основе содержимого, \
которое в случае фрагментации UDP-пакета, может быть неполным или идти не по порядку, \
что в свою очередь может быть интерпретировано как, например, DDoS атака.

Task 11: \
Зависит от того на сколько критичных логов (информации об приближении к пределам аппаратных ограничений или падении критичного компонента системы -- TCP). 
Для сбора INFO и WARNING логов, логов используемых в HEALTHCHECK, можно было использовать UDP, но опять же зависит от того, на сколько лог характеризует состояние системы.

syslog -- стандарт отправки и регистрации сообщений о происходящих в системе событиях, стандартом предусматривается, что источники формируют простые текстовые сообщения о происходящих в них событиях и передают их на обработку серверу Syslog (называемому «syslogd», «syslog daemon», либо же, «syslog server»), используя один из сетевых протоколов семейства IP (UDP или TCP).

Task 12: \
```sudo ss -tulpn | grep LISTEN```
Вывод
```
tcp    LISTEN   0        4096              0.0.0.0:19999          0.0.0.0:*      users:(("netdata",pid=776,fd=4))
tcp    LISTEN   0        4096              0.0.0.0:111            0.0.0.0:*      users:(("rpcbind",pid=584,fd=4),("systemd",pid=1,fd=35))
tcp    LISTEN   0        511               0.0.0.0:80             0.0.0.0:*      users:(("nginx",pid=726,fd=6),("nginx",pid=725,fd=6),("nginx",pid=724,fd=6),("nginx",pid=723,fd=6),("nginx",pid=722,fd=6))
tcp    LISTEN   0        4096        127.0.0.53%lo:53             0.0.0.0:*      users:(("systemd-resolve",pid=585,fd=13))
tcp    LISTEN   0        128               0.0.0.0:22             0.0.0.0:*      users:(("sshd",pid=799,fd=3))
tcp    LISTEN   0        511               0.0.0.0:443            0.0.0.0:*      users:(("nginx",pid=726,fd=8),("nginx",pid=725,fd=8),("nginx",pid=724,fd=8),("nginx",pid=723,fd=8),("nginx",pid=722,fd=8))
tcp    LISTEN   0        4096            127.0.0.1:8125           0.0.0.0:*      users:(("netdata",pid=776,fd=24))
tcp    LISTEN   0        4096                    *:9100                 *:*      users:(("node_exporter",pid=658,fd=3))
tcp    LISTEN   0        4096                 [::]:111               [::]:*      users:(("rpcbind",pid=584,fd=6),("systemd",pid=1,fd=37))
tcp    LISTEN   0        511                  [::]:80                [::]:*      users:(("nginx",pid=726,fd=7),("nginx",pid=725,fd=7),("nginx",pid=724,fd=7),("nginx",pid=723,fd=7),("nginx",pid=722,fd=7))
tcp    LISTEN   0        128                  [::]:22                [::]:*      users:(("sshd",pid=799,fd=4))
tcp    LISTEN   0        4096                [::1]:8125              [::]:*      users:(("netdata",pid=776,fd=23))
```

Task 13: \
```tspdump -x``` -- в HEX \
```tspdump -X``` -- в HEX и ASCII

Task 14:
```
sudo tshark -D
```
```
1. eth0
2. lo (Loopback)
3. any
4. bluetooth-monitor
5. nflog
6. nfqueue
7. ciscodump (Cisco remote capture)
8. dpauxmon (DisplayPort AUX channel monitor capture)
9. randpkt (Random packet generator)
10. sdjournal (systemd Journal Export)
11. sshdump (SSH remote capture)
12. udpdump (UDP Listener remote capture)
```
```
sudo tshark -V -i eth0
```
```
Ethernet II, Src: PcsCompu_e3:90:c5 (08:00:27:e3:90:c5), Dst: RealtekU_12:35:02 (52:54:00:12:35:02)
    Destination: RealtekU_12:35:02 (52:54:00:12:35:02)
        Address: RealtekU_12:35:02 (52:54:00:12:35:02)
        .... ..1. .... .... .... .... = LG bit: Locally administered address (this is NOT the factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Source: PcsCompu_e3:90:c5 (08:00:27:e3:90:c5)
        Address: PcsCompu_e3:90:c5 (08:00:27:e3:90:c5)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Type: IPv4 (0x0800)
Internet Protocol Version 4, Src: 10.0.2.15, Dst: 10.0.2.2 <-- Заголовки IP
    0100 .... = Version: 4 <-- Заголовки IP
    .... 0101 = Header Length: 20 bytes (5) <-- Заголовки IP
    Differentiated Services Field: 0x10 (DSCP: Unknown, ECN: Not-ECT) <-- Заголовки IP
        0001 00.. = Differentiated Services Codepoint: Unknown (4)
        .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0)
    Total Length: 192 <-- Заголовки IP
    Identification: 0x7003 (28675)
    Flags: 0x40, Don't fragment
        0... .... = Reserved bit: Not set
        .1.. .... = Don't fragment: Set
        ..0. .... = More fragments: Not set
    Fragment Offset: 0
    Time to Live: 64 <-- Заголовки IP
    Protocol: TCP (6)
    Header Checksum: 0xb214 [validation disabled]
    [Header checksum status: Unverified]
    Source Address: 10.0.2.15
    Destination Address: 10.0.2.2
```
```RealtekU_12:35:02 (52:54:00:12:35:02)``` -- ```52:54:00:12``` <- OUI

Заголовки IP:
1. Version IPv4, IPv6
2. IP Header Length
3. Time To Live
4. ...и.т.д...