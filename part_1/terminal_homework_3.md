Task 1:
```
type cd
cd is a shell builtin
```

Task 2:
```
grep -c <some_string> <some_file>
```

Task 3: \
Для
```
cat /proc/version
Linux version 5.4.0-73-generic (buildd@lcy01-amd64-019) (gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)) 
#82-Ubuntu SMP Wed Apr 14 17:39:42 UTC 2021
```
процесс запускаемый командой /sbin/init имеет PID 1
1. первый пользовательский процесс в Unix-подобных операционных системах
2. запускается непосредственно ядром системы.
3. является пра-родителем всех пользовательских (userspace) процессов системы.
4. стартует систему и управляет системой

Task 4:
```
tty <- получаем идентификатор терминала пусть 0
открываем новый терминал
tty <- пусть 1

Из терминала с номером 0 выполним
ls > /dev/pts/1

или
echo $$ -- получим pid процесса

ls > /proc/<pid другого терминала>/fd/1
```

Task 5: получится
```
cat < test.txt > test1.txt
```

Task 6: \
Эмулятор терминала запускает дочерний процесс – shell того пользователя,
под которым произведен вход в графическую оболочку систему. \
Стандартные потоки ввода-вывода этого shell указывают на /dev/pts/X. По идее, если знать номер shell в /dev/ptsX. \
То можно сканировать stdin. Т.е. сделать что-то типа такого:
Пусть есть 2 терминала /dev/pts/0 и /dev/pts/1:
```
В /dev/pts/0 выполним
cat < /dev/pts/1

В /dev/pts/1 будем набирать текст и он будет отображаться в stdout cat из первого терминала.
```

Task 7:
```
bash i>&1 -- создает файловый дескриптор с номером i для данного терминала (стандартизированы 0, 1, 2, 255)
и перенаправляет в stdout текущего терминала.

echo netology > /proc/$$/fd/i -- перенаправляет поток вывода команды echo в файловый дескриптор i текущего терминала,
который в свою очередь перенаправляет вывод в stdout.

Аналогично можно создать файловый дескриптор для записи в какой-нибудь файл:

bash i>t.txt
echo TEST1 1>&i
echo TEST2 1>&i
echo TEST3 1>&i

и результатом команды

cat t.txt

будет

TEST1
TEST2
TEST3
```

Task 8:
```
<command> 3>&1 1>&2 2>&3 | tee -a err.txt
```

Task 9: \
```echo $$```  -- выводит pid процесса терминала из которого выполняется команда. \
```cat /proc/$$/environ``` -- выводит переменные окружения терминала из которого запущена. \
```printenv``` -- выводит все переменные окружения терминала из которого запущена. \
```ps e -p $$``` -- выводит параметры с которыми он запущен процесс терминала в графе COMMAND. \

Результат вызова:
```
 PID TTY      STAT   TIME COMMAND
1181 pts/0    Ss     0:00 -bash LC_TERMINAL_VERSION=3.4.9beta1 LANG=en_US.UTF-8 LC_TERMINAL=iTerm2 USER=vagrant LOGNAME=vagrant HOME=/home/vagrant PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr
```

Task 10:
```
man proc

/proc/[pid]/cmdline
Файл содержит команда с аргументами запустившая процесс с [pid].


/proc/[pid]/exe
Путь "по которому" была запущенна команды с [pid].

ls -la /proc/$$/
exe -> /usr/bin/bash
```

Task 11:
```
cat /proc/cpuinfo | grep -i SSE
```

Task 12: \
По умолчанию когда выполняются команды на удаленной машине, через установку ssh соединения, TTY не выделяется для удаленной сессии. \
Можно запустить ```ssh``` с флагом ```-t```, который заставляет выделить pseudo-terminal для ssh сессии.
```
ssh -t localhost 'tty'
```

Task 13: \
0. Открываем два окна терминала
1. Логинимся за root и выполняем
```
echo 0 > /proc/sys/kernel/yama/ptrace_scope
либо
изменяем файл /etc/sysctl.d/10-ptrace.conf под рутом и чтобы после ребута VM сохранилось ptrace_scope = 0.
```
2. В первом окне запускаем процесс
```
ping yandex.ru
CTRL-Z
bg ping
disown ping
```
3. Во втором окне запускаем screen
```
screen
ps a <-- находим пид процесса
reptyr [pid] (или sudo reptyr -T [pid]) <-- присоединяем процесс к текущему screen
CTRL-A CTRL-D <-- выходим из screen
```
Но подобный подход с ping не работает, но работает с top. 
Reptyr не хватает прав для переноса процесса ping (также попробовал запускать ping yandex.ru > log.txt 2>&1)
Unable to attach to pid [pid]: Permission denied.

Почему не работает с ping, я так и не понял.

Альтернативы:
1) Следить за руками и запускать процессы через (можно предварительно обернуть в sh скрипт)
```
nohup [command] > log.txt 2>&1 &
```
2) Открывать screen сразу после открытия ssh сессии.

Task 14:
tee в Linux считывает стандартный ввод и записывает его одновременно в стандартный вывод \
и в один или несколько подготовленных файлов. 
```
 ... | sudo tee ... <-- по сути мы запускаем tee c привелегиями root пользователя
```
