Task 1:
```
type cd
cd is a shell builtin
```

Task 2:
```
grep -c <some_string> <some_file>
```

Task 3: процесс запускаемый командой /sbin/init имеет PID 1
1. первый пользовательский процесс в Unix-подобных операционных системах
2. запускается непосредственно ядром системы.
3. является пра-родителем всех пользовательских (userspace) процессов системы.
4. стартует систему и управляет системой

Task 4:
```
tty <- получаем идентификатор терминала пусть 0
открываем новый терминал
tty <- пусть 1

Из терминала с номером 0 выполним
ls > /dev/pts/1

или
echo $$ -- получим pid процесса

ls > /proc/<pid другого терминала>/fd/1
```

Task 5: получится
```
cat test.txt > test1.txt
```

Task 6: \
Эмулятор терминала запускает дочерний процесс – shell того пользователя,
под которым произведен вход в графическую оболочку систему. \
Стандартные потоки ввода-вывода этого shell указывают на /dev/pts/X. По идее, если знать номер shell в /dev/ptsX. \
То можно сканировать stdin. Т.е. сделать что-то типа такого:
Пусть есть 2 терминала /dev/pts/0 и /dev/pts/1:
```
В /dev/pts/0 выполним
cat < /dev/pts/1

В /dev/pts/1 будем набирать текст и он будет отображаться в stdout cat из первого терминала.
```

Task 7:
```
bash i>&1 -- создает файловый дескриптор с номером i для данного терминала (стандартизированы 0, 1, 2, 255)
и перенаправляет в stdout текущего терминала.

echo netology > /proc/$$/fd/i -- перенаправляет поток вывода команды echo в файловый дескриптор i текущего терминала,
который в свою очередь перенаправляет вывод в stdout.

Аналогично можно создать файловый дескриптор для записи в какой-нибудь файл:

bash i>t.txt
echo TEST1 1>&8
echo TEST2 1>&8
echo TEST3 1>&8

и результатом команды

cat t.txt

будет

TEST1
TEST2
TEST3
```

Task 8:
```
bash i>&1
<command> 2>&1 >/proc/$$/fd/i | tee -a err.txt
```

Task 9:
```
ps e -p $$
```

Task 10:
```
man proc

/proc/[pid]/cmdline
Файл содержит команда с аргументами запустившая процесс с [pid].


/proc/[pid]/exe
Путь "по которому" была запущенна команды с [pid].

ls -la /proc/$$/
exe -> /usr/bin/bash
```

Task 11:
```
cat /proc/cpuinfo | grep -i SSE
```

Task 13:
0. Открываем два окна терминала
1. Логинимся за root и выполняем
```
echo 0 > /proc/sys/kernel/yama/ptrace_scope
либо
изменяем файл /etc/sysctl.d/10-ptrace.conf под рутом и чтобы после ребута VM сохранилось ptrace_scope = 0.
```
3. В первом окне запускаем процесс
```
ping yandex.ru
CTRL-Z
bg ping
disown ping
```
3. Во втором окне запускаем screen
```
screen
ps a <-- находим пид процесса
reptyr [pid] (или sudo reptyr -T [pid]) <-- присоединяем процесс к текущему screen
CTRL-A CTRL-D <-- выходим из screen
```
Но подобный подход с ping не работает, но работает с top. 
Reptyr не хватает прав для переноса процесса ping (также попробовал запускать ping yandex.ru > log.txt 2>&1)
Unable to attach to pid [pid]: Permission denied.

Почему не работает с ping, я так и не понял.

Альтернативы:
1) Следить за руками и запускать процессы через (можно предварительно обернуть в sh скрипт)
```
nohup [command] > log.txt 2>&1 &
```
2) Открывать screen сразу после открытия ssh сессии.

Task 14:
tee в Linux считывает стандартный ввод и записывает его одновременно в стандартный вывод \
и в один или несколько подготовленных файлов. 
```
 ... | sudo tee ... <-- по сути мы запускаем tee c привелегиями root пользователя
```
